// == Module config.cc ==

// NOTE: This file has been generated by CMake. Do not edit.

// Make a string from a macro
#include "boost/preprocessor/stringize.hpp"

// -- Own headers --

#include "multovl/config.hh"

// -- Third-party headers --

// Mandatory libraries
#include "boost/version.hpp"

// -- Standard headers --

#include <climits>
#include <sstream>
#include <tuple>
#include <thread>
	
// == Implementation ==

namespace multovl {
namespace config {

const VersionInfo vinfo{};

std::string versioninfo() {
    return vinfo.str("Multovl");
}

std::string detailed_versioninfo() {
    std::ostringstream oss;
    
    oss << vinfo.str("Multovl") << std::endl;
    
    oss << "Built on "
        << __DATE__ << " at " << __TIME__ << std::endl << std::endl;

    oss <<  "Git revision: " << git_full_checksum() << std::endl
        << "Revision date: " << git_revision_date() << std::endl;
    
    oss << "Build type: " << build_type() << std::endl
        << "Compilers: " << build_compiler() << std::endl
        << num_threads() << std::endl
        << "System: " << build_system() << std::endl << std::endl;

    oss << "Third-party libraries:" << std::endl
        << vinfo.str("Boost") << std::endl
        << vinfo.str("BamTools") << std::endl;
    
    return oss.str();
}

std::string library_version(const std::string& pkgname) {
    try {
        return vinfo.get(pkgname).str();
    } catch(const std::out_of_range& ex) {
        return "";
    }
}

std::string build_type() { return BOOST_PP_STRINGIZE(@CMAKE_BUILD_TYPE@); }

std::string build_compiler() {
    std::string cid = BOOST_PP_STRINGIZE(@CMAKE_C_COMPILER_ID@),
        cver = BOOST_PP_STRINGIZE(@CMAKE_C_COMPILER_VERSION@),
        cxxid = BOOST_PP_STRINGIZE(@CMAKE_CXX_COMPILER_ID@),
        cxxver = BOOST_PP_STRINGIZE(@CMAKE_CXX_COMPILER_VERSION@);
    if (cid == cxxid && cver == cxxver) {
        return cid + " " + cver;
    } else {
        return cid + " " + cver + " / " + cxxid + " " + cxxver;
    }
}

std::string build_system() {
    static constexpr unsigned int BITSIZE = CHAR_BIT * sizeof(void*);
	
	std::ostringstream oss;
	oss << BOOST_PP_STRINGIZE(@CMAKE_SYSTEM_NAME@ @CMAKE_SYSTEM_VERSION@ @CMAKE_SYSTEM_PROCESSOR@)
	    << " (" << BITSIZE << "-bit)";
    return oss.str();
}

unsigned int thread_no() {
    return(std::thread::hardware_concurrency());
}

std::string num_threads() {
    std::ostringstream oss;
    oss << "Number of available hardware threads: " << thread_no();
    return oss.str();
}

std::string git_full_checksum() { return BOOST_PP_STRINGIZE(@GITREV_SHA1@); }
std::string git_short_checksum() { return BOOST_PP_STRINGIZE(@GITREV_SHA1SHORT@); }
std::string git_revision_date() { return BOOST_PP_STRINGIZE(@GITREV_DATE@); }
unsigned int git_revision_count() { return @GITREV_COUNT@ ; }

// -- Version methods --

Version::Version(
    const ver_t& maj,
    const ver_t& min,
    const ver_t& pat
) {
    std::string s = _tostr(maj) + "." + _tostr(min);
    std::string patstr = _tostr(pat);
    if (patstr != "") {
        s += "." + patstr;
    }
    _str = s;
}

std::string Version::_tostr(const ver_t& m) {
    if (m.index() == 1) {
        return std::to_string(std::get<int>(m));
    } else {
        return std::get<std::string>(m);
    }
}

// -- VersionInfo methods --

// The ctor deals with all the gory details of getting the version numbers.
VersionInfo::VersionInfo()
{
    add_inplace("Multovl", 
        BOOST_PP_STRINGIZE(@MULTOVL_VERSION_MAJOR@),
        BOOST_PP_STRINGIZE(@MULTOVL_VERSION_MINOR@),
        @GITREV_COUNT@ // use the revision count as patchlevel, always uint
    );   
    add_inplace("Boost",
        BOOST_VERSION / 100000, BOOST_VERSION / 100 % 1000, BOOST_VERSION % 100);
    add_inplace("BamTools", "2.3.2 (AA)");
}

// see https://stackoverflow.com/questions/27960325/stdmap-emplace-without-copying-value
void VersionInfo::add_inplace(
    const std::string& pkgname,
    const Version::ver_t& maj,
    const Version::ver_t& min,
    const Version::ver_t& pat
) {
    _vers.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(pkgname), // the key
        std::forward_as_tuple(maj, min, pat)    // the value
    );
}

void VersionInfo::add_inplace(
    const std::string& pkgname,
    const std::string& versionstr
) {
    _vers.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(pkgname), // the key
        std::forward_as_tuple(versionstr)    // the value
    );
}

std::string VersionInfo::str(const std::string& pkgname) const {
    Version v{ get(pkgname) };
    std::string s{ pkgname + " version " + v.str() };
    return s;
}

}   // namespace config
}   // namespace multovl
